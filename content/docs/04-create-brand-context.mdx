---
title: Refactoring create-brand-context route
---

import { Step, Steps } from "fumadocs-ui/components/steps";

<Steps>

<Step>
Let's start by creating schema for our brand context. It's not a hard schema so it can be very simple JSON object. However the better context we will give to the LLM the better the job it will perform.

```ts title="app/api/create-brand-context/route.ts"
import { type NextRequest, NextResponse } from "next/server";
import { generateText } from "ai";
import { redis } from "@/lib/upstash";
import { z } from "zod"; // [!code highlight]

// Schema for brand context // [!code highlight]
const brandContextSchema = z.object({
  // [!code highlight]
  description: z.string().describe("What the brand/product is"), // [!code highlight]
  keyFeatures: z.array(z.string()).describe("Key features and offerings"), // [!code highlight]
  targetAudience: z.string().describe("Target audience"), // [!code highlight]
  industry: z.string().describe("Industry and category"), // [!code highlight]
  valuePropositions: z.array(z.string()).describe("Unique value propositions"), // [!code highlight]
  comprehensiveSummary: z // [!code highlight]
    .string() // [!code highlight]
    .describe("A comprehensive paragraph summary for generating questions"), // [!code highlight]
}); // [!code highlight]
```

</Step>

<Step>
Let's add a tool that will list files and directories at a given path. If no path is provided, it should list files in the current directory.

```ts title="utils/agent.ts"
import { generateText, tool } from "ai";
import z from "zod/v4";
import fs from "fs"; // [!code highlight]

export async function codingAgent(prompt: string) {
  const result = await generateText({
    model: "openai/gpt-4.1-mini",
    prompt,
    system:
      "You are a coding agent. You will be working with js/ts projects. Your responses must be concise.",
    tools: {
      // [!code highlight]
      list_files: tool({
        // [!code highlight]
        // [!code highlight]
        description:
          "List files and directories at a given path. If no path is provided, lists files in the current directory.", // [!code highlight]
        inputSchema: z.object({
          // [!code highlight]
          path: z // [!code highlight]
            .string() // [!code highlight]
            .nullable() // [!code highlight]
            .describe(
              // [!code highlight]
              "Optional relative path to list files from. Defaults to current directory if not provided." // [!code highlight]
            ), // [!code highlight]
        }), // [!code highlight]
        execute: async ({ path: generatedPath }) => {
          // [!code highlight]
          if (generatedPath === ".git" || generatedPath === "node_modules") {
            // [!code highlight]
            return { error: "You cannot read the path: ", generatedPath }; // [!code highlight]
          } // [!code highlight]
          const path = generatedPath?.trim() ? generatedPath : "."; // [!code highlight]
          try {
            // [!code highlight]
            console.log(`Listing files at '${path}'`); // [!code highlight]
            const output = fs.readdirSync(path, {
              // [!code highlight]
              recursive: false, // [!code highlight]
            }); // [!code highlight]
            return { path, output }; // [!code highlight]
          } catch (e) {
            // [!code highlight]
            console.error(`Error listing files:`, e); // [!code highlight]
            return { error: e }; // [!code highlight]
          } // [!code highlight]
        }, // [!code highlight]
      }), // [!code highlight]
    }, // [!code highlight]
  });

  return { response: result.text };
}
```

Run the script again.

Notice we don't see any output? We need to make our call agentic by defining new stopping conditions with `stopWhen`.

</Step>

<Step>
Define a stopping condition with the `stopWhen` property.

```ts title="utils/agent.ts"
import { generateText, stepCountIs, tool } from "ai"; // [!code highlight]
import z from "zod/v4";
import fs from "fs";

export async function codingAgent(prompt: string) {
  const result = await generateText({
    model: "openai/gpt-4.1-mini",
    prompt,
    system:
      "You are a coding agent. You will be working with js/ts projects. Your responses must be concise.",
    stopWhen: stepCountIs(10), // [!code highlight]
    tools: {
      list_files: tool({
        description:
          "List files and directories at a given path. If no path is provided, lists files in the current directory.",
        inputSchema: z.object({
          path: z
            .string()
            .nullable()
            .describe(
              "Optional relative path to list files from. Defaults to current directory if not provided."
            ),
        }),
        execute: async ({ path: generatedPath }) => {
          if (generatedPath === ".git" || generatedPath === "node_modules") {
            return { error: "You cannot read the path: ", generatedPath };
          }
          const path = generatedPath?.trim() ? generatedPath : ".";
          try {
            console.log(`Listing files at '${path}'`);
            const output = fs.readdirSync(path, {
              recursive: false,
            });
            return { path, output };
          } catch (e) {
            console.error(`Error listing files:`, e);
            return { error: e };
          }
        },
      }),
    },
  });

  return {
    response: result.text,
  };
}
```

Run the script again.

Notice now the "agent' is taking multiple steps to understand the project. However, notice now it's restricted by it's one tool. Let's add a tool to help it read files.

</Step>

<Step>

The `read_file` tool should look similar to our `list_files` tool.

```ts title="utils/agent.ts"
import { generateText, stepCountIs, tool } from "ai";
import z from "zod/v4";
import fs from "fs";

export async function codingAgent(prompt: string) {
  const result = await generateText({
    model: "openai/gpt-4.1-mini",
    prompt,
    system:
      "You are a coding agent. You will be working with js/ts projects. Your responses must be concise.",
    stopWhen: stepCountIs(10),
    tools: {
      list_files: tool({
        description:
          "List files and directories at a given path. If no path is provided, lists files in the current directory.",
        inputSchema: z.object({
          path: z
            .string()
            .nullable()
            .describe(
              "Optional relative path to list files from. Defaults to current directory if not provided."
            ),
        }),
        execute: async ({ path: generatedPath }) => {
          if (generatedPath === ".git" || generatedPath === "node_modules") {
            return { error: "You cannot read the path: ", generatedPath };
          }
          const path = generatedPath?.trim() ? generatedPath : ".";
          try {
            console.log(`Listing files at '${path}'`);
            const output = fs.readdirSync(path, {
              recursive: false,
            });
            return { path, output };
          } catch (e) {
            console.error(`Error listing files:`, e);
            return { error: e };
          }
        },
      }),
      read_file: tool({
        // [!code highlight]
        // [!code highlight]
        description:
          "Read the contents of a given relative file path. Use this when you want to see what's inside a file. Do not use this with directory names.", // [!code highlight]
        inputSchema: z.object({
          // [!code highlight]
          path: z // [!code highlight]
            .string() // [!code highlight]
            .describe("The relative path of a file in the working directory."), // [!code highlight]
        }), // [!code highlight]
        execute: async ({ path }) => {
          // [!code highlight]
          try {
            // [!code highlight]
            console.log(`Reading file at '${path}'`); // [!code highlight]
            const output = fs.readFileSync(path, "utf-8"); // [!code highlight]
            return { path, output }; // [!code highlight]
          } catch (error) {
            // [!code highlight]
            console.error(`Error reading file at ${path}:`, error.message); // [!code highlight]
            return { path, error: error.message }; // [!code highlight]
          } // [!code highlight]
        }, // [!code highlight]
      }), // [!code highlight]
    },
  });

  return {
    response: result.text,
  };
}
```

Run the script again.

You should see the model list the files, then check the README. Finally, it responds with an overview of the project. Very cool, right?

</Step>

<Step>
We can even experiment here and ask the agent to tell us how the agent works!

```ts title="utils/agent.ts"
import { codingAgent } from "./agent";
import dotenv from "dotenv";

dotenv.config({ path: ".env.local" });

codingAgent("Tell me how this agent currently works.")
  .then(console.log)
  .catch(console.error);
```

Pretty wild, right? The agent is telling us how the agent works.

But what if we ask it to update the README to add a section for contributoring? Go to `utils/test.ts` and update the prompt to say:

```ts title="utils/agent.ts"
import { codingAgent } from "./agent";
import dotenv from "dotenv";

dotenv.config({ path: ".env.local" });

codingAgent(
  "Add a contributing section to the readme of this project. Use standard format." // [!code highlight]
)
  .then(console.log)
  .catch(console.error);
```

Notice it gets stuck in a loop. Let's add a tool to edit + create files.

</Step>

<Step>

Create a new tool called `edit_file` that will be used to edit or create files.

```ts title="utils/agent.ts"
import { generateText, stepCountIs, tool } from "ai";
import z from "zod/v4";
import fs from "fs";

export async function codingAgent(prompt: string) {
  const result = await generateText({
    model: "openai/gpt-4.1-mini",
    prompt,
    system:
      "You are a coding agent. You will be working with js/ts projects. Your responses must be concise.",
    stopWhen: stepCountIs(10),
    tools: {
      list_files: tool({
        description:
          "List files and directories at a given path. If no path is provided, lists files in the current directory.",
        inputSchema: z.object({
          path: z
            .string()
            .nullable()
            .describe(
              "Optional relative path to list files from. Defaults to current directory if not provided."
            ),
        }),
        execute: async ({ path: generatedPath }) => {
          if (generatedPath === ".git" || generatedPath === "node_modules") {
            return { error: "You cannot read the path: ", generatedPath };
          }
          const path = generatedPath?.trim() ? generatedPath : ".";
          try {
            console.log(`Listing files at '${path}'`);
            const output = fs.readdirSync(path, {
              recursive: false,
            });
            return { path, output };
          } catch (e) {
            console.error(`Error listing files:`, e);
            return { error: e };
          }
        },
      }),
      read_file: tool({
        description:
          "Read the contents of a given relative file path. Use this when you want to see what's inside a file. Do not use this with directory names.",
        inputSchema: z.object({
          path: z
            .string()
            .describe("The relative path of a file in the working directory."),
        }),
        execute: async ({ path }) => {
          try {
            console.log(`Reading file at '${path}'`);
            const output = fs.readFileSync(path, "utf-8");
            return { path, output };
          } catch (error) {
            console.error(`Error reading file at ${path}:`, error.message);
            return { path, error: error.message };
          }
        },
      }),
      edit_file: tool({
        // [!code highlight]
        // [!code highlight]
        description:
          "Make edits to a text file or create a new file. Replaces 'old_str' with 'new_str' in the given file. 'old_str' and 'new_str' MUST be different from each other. If the file specified with path doesn't exist, it will be created.", // [!code highlight]
        inputSchema: z.object({
          // [!code highlight]
          path: z.string().describe("The path to the file"), // [!code highlight]
          old_str: z // [!code highlight]
            .string() // [!code highlight]
            .nullable() // [!code highlight]
            .describe(
              // [!code highlight]
              "Text to search for - must match exactly and must only have one match exactly" // [!code highlight]
            ), // [!code highlight]
          new_str: z.string().describe("Text to replace old_str with"), // [!code highlight]
        }), // [!code highlight]
        execute: async ({ path, old_str, new_str }) => {
          // [!code highlight]
          try {
            // [!code highlight]
            const fileExists = fs.existsSync(path); // [!code highlight]
            if (fileExists && old_str !== null) {
              // [!code highlight]
              console.log(`Editing file '${path}'`); // [!code highlight]
              const fileContents = fs.readFileSync(path, "utf-8"); // [!code highlight]
              const newContents = fileContents.replace(old_str, new_str); // [!code highlight]
              fs.writeFileSync(path, newContents); // [!code highlight]
              return { path, success: true, action: "edit" }; // [!code highlight]
            } else {
              // [!code highlight]
              console.log(`Creating file '${path}'`); // [!code highlight]
              fs.writeFileSync(path, new_str); // [!code highlight]
              return { path, success: true, action: "create" }; // [!code highlight]
            } // [!code highlight]
          } catch (e) {
            // [!code highlight]
            console.error(`Error editing file ${path}:`, e); // [!code highlight]
            return { error: e, success: false }; // [!code highlight]
          } // [!code highlight]
        }, // [!code highlight]
      }), // [!code highlight]
    },
  });

  return {
    response: result.text,
  };
}
```

Run the script again.

Check your `README`. You should see a new section for contributing added. How cool, right?!

</Step>

</Steps>

You've just created a coding agent!
